#lang racket/base

(require forge/sigs-structs)
(require forge/breaks)
(require forge/lang/ast)
(require forge/lang/bounds)
(require forge/shared
         (prefix-in tree: forge/lazy-tree)
         forge/last-checker
         forge/choose-lang-specific
         forge/translate-to-kodkod-cli
         forge/translate-from-kodkod-cli)
(require (prefix-in @ (only-in racket/base >= not - = and or max > < +))
         (only-in racket match first rest empty empty? set->list list->set set-intersect set-union
                         curry range index-of pretty-print filter-map string-prefix? string-split thunk*
                         remove-duplicates subset? cartesian-product match-define cons? set-subtract)
          racket/hash)
(require (only-in syntax/srcloc build-source-location-syntax))
(require (prefix-in pardinus: forge/pardinus-cli/server/kks)
         (prefix-in pardinus: forge/pardinus-cli/server/server)
         (prefix-in pardinus: forge/pardinus-cli/server/server-common))

; Disable DrRacket GUI extension/tool
;(require "drracket-gui.rkt")

(provide send-to-kodkod)

(define no-version-printed-yet #t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;    Run Logic    ;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Will be a Server-ports tuple if a server is active. 
(define server-state (box #f))
; In order to prevent a bad crash, keep track of run-names used in the past, 
; and throw a friendlier error if one is re-used. 
(define run-name-history (box (list)))

; send-to-kodkod :: Run-spec -> Stream<model>, List<Symbol>
; Given a Run-spec structure, processes the data and communicates it to KodKod-CLI;
; then produces a stream to produce instances generated by KodKod, 
; along with a list of all of the atom names for sig atoms.
(define (send-to-kodkod run-spec run-command #:run-name [run-name (gensym)])
  (do-time "send-to-kodkod")
  
  ; In case of error, highlight an AST node if able. Otherwise, focus on the offending run command.
  (define (raise-run-error message [node #f])
    (if node
        (raise-forge-error #:msg message
                           #:context (nodeinfo-loc (node-info node)))
        (raise-forge-error #:msg message
                           #:context run-command)))
  
  (when (member run-name (unbox run-name-history))
    (raise-run-error (format "Run name ~a was re-used; please use a different run name.~n" run-name)))
  (set-box! run-name-history (cons run-name (unbox run-name-history)))

  ; Print version number, so students know to update
  (when (and no-version-printed-yet (@>= (get-verbosity) VERBOSITY_LOW))
    (set! no-version-printed-yet #f)
    (printf "Forge version: ~a~n" forge-version)
    (let ([git-info (forge-git-info)])
      (when (pair? git-info)
        (apply printf " branch: ~a~n commit: ~a~n timestamp: ~a~n" git-info)))
    (printf "To report issues with Forge, please visit ~a~n"
            "https://report.forge-fm.org"))
  
  ; Do relation breaks from declarations
  (define relation-constraints 
    (apply append
           (for/list ([relation (get-relations run-spec)])
             (match (Relation-breaker relation)
               [#f (list)]
               ['default (list)]
               ['pfunc (let* ([rel relation]
                              [sigs (map (lambda (sig-thunk) (sig-thunk))
                                         (Relation-sigs-thunks relation))]
                              [left-sig (get-sig run-spec (first sigs))]
                              [sig-rel left-sig])
                         (list (all ([s sig-rel])
                                 (lone (join s rel)))))]
               [other (break relation other)
                      (list)]))))

  (define-values (sig-to-bound relation-to-bound all-atoms)
    (get-bounds run-spec raise-run-error))

  (map instance (hash-values (Bound-pbindings (Run-spec-bounds run-spec))))
  
  ; Get new bounds and constraints from breaks
  (define-values (total-bounds break-preds)
    (let* ([sig-bounds (map (compose (curry hash-ref sig-to-bound )
                                     Sig-name)
                            (get-sigs run-spec))]
           [relation-bounds (map (compose (curry hash-ref relation-to-bound )
                                          Relation-name)
                                 (get-relations run-spec))]
           [total-bounds (append sig-bounds relation-bounds)]

           [sigs (get-sigs run-spec)]
           [sig-rels (filter (lambda (sig) (@not (equal? (Sig-name sig) 'Int))) sigs)]
           [upper-bounds (for/hash ([sig sigs]) 
                           (values sig
                                   (map car (bound-upper (hash-ref sig-to-bound (Sig-name sig))))))]
           [relations-store (for/hash ([relation (get-relations run-spec)]
                                       #:unless (equal? (Relation-name relation) 'succ))
                              (values relation (get-sigs run-spec relation)))]
           [extensions-store (for/hash ([sig sigs]
                                        #:when (Sig-extends sig))
                               (values sig (get-sig run-spec (Sig-extends sig))))])
      ;(printf "args-- total-bounds : ~a~n args-- sig-rels : ~a~n args-- upper-bounds : ~a~n" total-bounds sig-rels upper-bounds )
      (constrain-bounds total-bounds sig-rels upper-bounds relations-store extensions-store)))
  ;(printf "after-- total-bounds : ~a~n" total-bounds)
  (clear-breaker-state)

  (define sigs-and-rels
    (append (State-sig-order (Run-spec-state run-spec))
            (State-relation-order (Run-spec-state run-spec))))
  (set! total-bounds (map (lambda (name) 
                            (findf (lambda (b) 
                                     (equal? name (string->symbol (relation-name (bound-relation b)))))
                                   total-bounds)) 
                          sigs-and-rels))

  (when (@>= (get-verbosity) VERBOSITY_DEBUG)
    (displayln "--------------------------")
    (printf "Original PBindings: ~n~a~n~n" (Bound-pbindings (Run-spec-bounds run-spec)))
    (printf "sig-to-bound: ~n~a~n~n" sig-to-bound)
    (printf "relation-to-bound: ~n~a~n~n" relation-to-bound)
    (printf "all-atoms: ~n~a~n~n" all-atoms)
    (printf "total-bounds: ~n~a~n~n" total-bounds)
    (displayln "--------------------------"))

  #| Print to KodKod-CLI
    print configure
    declare univ size
    declare ints
    print Int sig (r0)
    print other sigs (r2 ... rm)
    print succ relation (r(m + 1))
    print other relations (r(m + 2) ... rn)
    print formula / assert formula (f0 ... fk)
    print solve
  |#

  ; Initializing our kodkod-cli process, and getting ports for communication with it
  (define backend (get-option run-spec 'backend))
  (define-values (stdin stdout stderr shutdown is-running?) 
    (cond
      ; if there is an active server state, and the server is running
      [(and (unbox server-state) ((Server-ports-is-running? (unbox server-state))))
       (define sstate (unbox server-state))
       (when (@> (get-verbosity) VERBOSITY_LOW)
        (printf "Pardinus solver process already running. Preparing to start new run with id ~a.~n" run-name))
       (values (Server-ports-stdin sstate) (Server-ports-stdout sstate) 
               (Server-ports-stderr sstate) (Server-ports-shutdown sstate)
               (Server-ports-is-running? sstate))]
      [(equal? backend 'kodkod)
       (raise "Pure Kodkod backend is no longer supported; please use Pardinus backend.")]
      [(equal? backend 'pardinus)
       (when (@>= (get-verbosity) VERBOSITY_HIGH)
         (printf "Starting/restarting Pardinus server (prior state=~a)...~n" (unbox server-state)))
       (pardinus:start-server
        'stepper ; always a stepper problem (there is a "next" button)
        ; 'default, 'temporal, or 'target (tells Pardinus which solver to load,
        ;  and affects parsing so needs to be known at invocation time)
        (get-option run-spec 'problem_type))]
      [else (raise (format "Invalid backend: ~a" backend))]))

  ; (define-syntax-rule (kk-print lines ...)
  ;   (kodkod:cmd 
  ;     [stdin]
  ;     lines ...))

  ; Print targets
  (define-syntax-rule (pardinus-print lines ...)
    (pardinus:cmd 
      [stdin]
      lines ...))

  ; Confirm that if the user is invoking a custom solver, that custom solver exists
  (define solverspec (cond [(symbol? (get-option run-spec 'solver))
                            (get-option run-spec 'solver)]
                           [else (string-append "\"" (get-option run-spec 'solver) "\"")]))
  (unless (or (symbol? (get-option run-spec 'solver))
              (file-exists? (get-option run-spec 'solver)))
    (raise-user-error (format "option solver specified custom solver (via string): ~a, but file did not exist." 
                              (get-option run-spec 'solver))))
  
  ; Print configure and declare univ size
  ; Note that target mode is passed separately, nearer to the (solve) invocation
  (define bitwidth (get-bitwidth run-spec))


  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Generate top-level constraint for this run, execute last-checker
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
  (define (maybe-alwaysify fmla)
    (if (equal? 'temporal (get-option run-spec 'problem_type))
        (always/info (node-info fmla) fmla)
        fmla))
  
  ; If in temporal mode, need to always-ify the auto-generated constraints but not the
  ;   predicates that come from users
  (define raw-implicit-constraints
    (append (get-sig-size-preds run-spec sig-to-bound #:error raise-run-error)
            (get-relation-preds run-spec)
            (get-extender-preds run-spec)
            relation-constraints
            break-preds))
  (define conjuncts-implicit-constraints
    (apply append (map maybe-and->list raw-implicit-constraints)))
  (define implicit-constraints
    (map maybe-alwaysify conjuncts-implicit-constraints))
  (define explicit-constraints
    (apply append (map maybe-and->list (Run-spec-preds run-spec)))) 
  (define run-constraints 
    (append explicit-constraints implicit-constraints))

  ; Run last-minute checks for errors  
  (for-each (lambda (c)
              (checkFormula run-spec c '() (get-checker-hash)))
            run-constraints)
  
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Beginning to send to Pardinus. All type-checking must be complete _before_ this point.
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (pardinus-print (pardinus:print-cmd (format "(with ~a" run-name)))
  (pardinus-print
    (pardinus:configure (format ":bitwidth ~a :solver ~a :max-solutions 1 :verbosity ~a :skolem-depth ~a :sb ~a :core-gran ~a :core-minimization ~a :log-trans ~a ~a ~a"                               
                               bitwidth 
                               solverspec
                               (get-option run-spec 'engine_verbosity) ; see the Wiki for levels
                               (get-option run-spec 'skolem_depth)
                               (get-option run-spec 'sb) 
                               (get-option run-spec 'coregranularity)
                               (get-option run-spec 'core_minimization)
                               (get-option run-spec 'logtranslation)
                               (if (equal? 'temporal (get-option run-spec 'problem_type))
                                   (format ":min-trace-length ~a" (get-option run-spec 'min_tracelength))
                                   "")
                               (if (equal? 'temporal (get-option run-spec 'problem_type))
                                   (format ":max-trace-length ~a" (get-option run-spec 'max_tracelength))
                                   "")))
    (pardinus:declare-univ (length all-atoms)))

  ; Declare ints
  (define num-ints (expt 2 bitwidth))
  (pardinus-print
    (pardinus:declare-ints (range (@- (/ num-ints 2)) (/ num-ints 2)) ; ints
                           (range num-ints)))                        ; indexes

  ; to-tupleset :: List<List<int>>, int -> tupleset
  (define (to-tupleset arity eles)
    (if (empty? eles)
        (if (@= arity 1)
            'none
            (pardinus:product 'none (to-tupleset (sub1 arity) eles)))
        (pardinus:tupleset #:tuples eles)))

  (define (get-atoms rel atom-names)
    (define atoms 
      (for/list ([tup atom-names])
        (for/list ([atom tup])
          (unless (member atom all-atoms)
            (raise (format "atom (~a) not in all-atoms (~a)"
                           atom all-atoms)))
          (index-of all-atoms atom))))
    (define ret (to-tupleset (relation-arity rel) atoms))
    ret)

  (for ([rel (get-all-rels run-spec)]
        [bound total-bounds])
    (pardinus-print
      (pardinus:declare-rel
       (if (node/expr/relation-is-variable rel)
           (pardinus:x (relation-name rel))
           (pardinus:r (relation-name rel)))
        (get-atoms rel (bound-lower bound))
        (get-atoms rel (bound-upper bound)))))

  ; Declare assertions
  (define all-rels (get-all-rels run-spec))
  
  ; Keep track of which formula corresponds to which CLI assert
  ; for highlighting unsat cores. TODO: map back from CLI output
  ; constraints later
  (define core-map (make-hash))
  
  (for ([p run-constraints]
        [assertion-number (in-naturals)])
    (hash-set! core-map assertion-number p)
    (pardinus-print
      (pardinus:print-cmd-cont "(~a " (pardinus:f assertion-number))
      (translate-to-kodkod-cli run-spec p all-rels all-atoms '())
      (pardinus:print-cmd ")")
      (pardinus:assert (pardinus:f assertion-number))))

  ; target-oriented model finding may not impose an initial target, but might
  ; be used just to implement custom "next" strategies
  (when (equal? 'target (get-option run-spec 'problem_type))
    (define target (Run-spec-target run-spec))    
    (when target
      (for ([(rel-name atoms) (Target-instance target)])
        (define relation (hash-ref (get-relation-map run-spec) (symbol->string rel-name)))
        (define sig-or-rel
          (if (@= (relation-arity relation) 1)
              (get-sig run-spec relation)
              (get-relation run-spec relation)))
        
        (pardinus-print
         (pardinus:declare-target 
          (pardinus:r (relation-name relation))
          (get-atoms relation atoms)))))

    ; Always say what mode; admittedly this won't always make sense if untargeted
    ; Conflate "target distance" declared with a concrete target and global mode.
    ;    Note well: the space of possible options should mirror the contract on this field.
    (pardinus-print
     (pardinus:print-cmd "(target-option target-mode ~a)"
                         (if target
                             (Target-distance target)
                             (get-option run-spec 'target_mode)))))

  ; Close the "with" scope.
  (pardinus-print (pardinus:print-cmd ")"))
  (pardinus-print (pardinus:print-eoi))
  ; Wait for the acknowledgement before sending more messages.
  (pardinus:read-ack stdout stderr)
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; DO NOT ADD MORE MESSAGES TO PARDINUS AFTER THIS POINT
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define (format-statistics stats)
    (let* ([vars (assoc 'size-variables stats)]
           [prim (assoc 'size-primary stats)]
           [clauses (assoc 'size-clauses stats)]
           [tt (assoc 'time-translation stats)]
           [ts (assoc 'time-solving stats)]
           [tcx (assoc 'time-core stats)]
           [tcstr (if tcx (format " Core min (ms): ~a" tcx) "")])
      (format "#vars: ~a; #primary: ~a; #clauses: ~a~nTransl (ms): ~a; Solving (ms): ~a~a"
              vars prim clauses tt ts tcstr)))
  
  ; Print solve
  (define (get-next-model [mode ""])
    ; If the solver isn't running at all, error:
    (unless (is-running?)
      (raise-user-error "KodKod server is not running."))
    ; If the solver is running, but this specific run ID is closed, user error
    (when (is-run-closed? run-name)
      (raise-user-error (format "Run ~a has been closed." run-name)))
    
    (pardinus-print (pardinus:solve run-name mode))
    (define result (translate-from-kodkod-cli
                    'run 
                    (pardinus:read-solution stdout stderr) 
                    all-rels 
                    all-atoms))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Note on cores: if core granularity is high, Kodkod may return a formula we do not have an ID for.
    ; In these cases, the engine should be passing something like "f:0,0" which indexes _child_ formulas.
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (define (traverse-path-list path [fmla #f])
      ;; Cannot use for/fold or fold here, because we need to _not_ move down the list for
      ;; a node/fmla/pred-spacer node (and any other node that is invisible to Pardinus).
      (cond
        ; Base case: no more indexes to process
        [(empty? path) fmla]
        ; We have an index, descend as appropriate
        [else 
         (define idx-str (first path))
         (define idx (string->number idx-str))
         (cond [(not fmla)
                (traverse-path-list (rest path)
                                    (hash-ref core-map idx))]
               [(node/formula/quantified? fmla)
                ; Quantified: decls formulas first, then sub-formula last
                (cond [(>= idx (length (node/formula/quantified-decls fmla)))
                       (traverse-path-list (rest path)
                                           (node/formula/quantified-formula fmla))]
                      [else
                       (define decl (list-ref (node/formula/quantified-decls fmla) idx))
                       (traverse-path-list (rest path)
                                           (car decl))])]
               [(node/formula/op? fmla)
                ; Operator formula: sub-formulas in order. Note that this layer isn't shown
                ; to Pardinus, so we cannot move down the path index list for this.
                (traverse-path-list (rest path)
                                    (list-ref (node/formula/op-children fmla) idx))]
               [(node/fmla/pred-spacer? fmla)
                ; Predicate spacer, just use internal formula, and don't move forward in the path
                (traverse-path-list path
                                    (node/fmla/pred-spacer-expanded fmla))]
               [else
                (raise-user-error (format "Unsupported formula type in core: ~a" fmla))])]))
    
    (define (find-core-formula id)
      (unless (string-prefix? id "f:")
        (raise-user-error (format "Unexpected error: invalid formula path ID: ~a" id)))
      (define path (string-split (first (string-split id "f:")) ","))
      (printf "core path: ~a~n" path)
      (unless (and (> (length path) 0) (member (string->number (first path)) (hash-keys core-map)))
        (raise-user-error (format "Unexpected error: solver path ID prefix was invalid: ~a; valid prefixes: ~a" id (hash-keys core-map))))
      (traverse-path-list path #f))
    
    (define (pretty-core idx max known? fmla-or-id)
      (cond [known?
             (define fmla fmla-or-id)
             (fprintf (current-error-port) "Core(part ~a/~a): [~a] ~a~n" (@+ idx 1) max
               (pretty-loc fmla) (deparse fmla))]
            [(string-prefix? fmla-or-id "f:")
             (define fmla (find-core-formula fmla-or-id))
             (fprintf (current-error-port) "Core(part ~a/~a): [~a] ~a~n" (@+ idx 1) max
               (pretty-loc fmla) (deparse fmla))]
            [else
             (fprintf (current-error-port) "Core(part ~a/~a): [UNKNOWN] ~a~n" (@+ idx 1) max
                fmla-or-id)]))
    
    
    (when (and (Unsat? result) (Unsat-core result)) ; if we have a core
      (when (@>= (get-verbosity) VERBOSITY_DEBUG)
        (printf "core-map: ~a~n" core-map)
        (printf "core: ~a~n" (Unsat-core result)))
      (when (@>= (get-verbosity) VERBOSITY_LOW) 
        (printf "Unsat core available (~a formulas):~n" (length (Unsat-core result))))
      (for ([id (Unsat-core result)]
            [idx (range (length (Unsat-core result)))])
        (let ([fmla-num (if (string-prefix? id "f:") (string->number (substring id 2)) #f)])
          (cond [(member fmla-num (hash-keys core-map))
                 ; This is a formula ID and we know it immediately; it's a top-level constraint
                 (pretty-core idx (length (Unsat-core result)) fmla-num (hash-ref core-map fmla-num))]
                [else
                 ; This is NOT a known top-level constraint, but it's part of the core
                 (pretty-core idx (length (Unsat-core result)) #f id)]))))
    
    (when (@>= (get-verbosity) VERBOSITY_LOW)
      (displayln (format-statistics (if (Sat? result) (Sat-stats result) (Unsat-stats result)))))
    result)

  (define (next-button type)
    (tree:make-node (get-next-model type) next-button))
  (define results
    (tree:make-node (get-next-model 'start) next-button))

  (set-box! server-state (Server-ports stdin stdout stderr shutdown is-running?))

  (values results 
          all-atoms 
          (unbox server-state)
          (Kodkod-current (length run-constraints) 0 0) 
          total-bounds))


(define (get-bounds run-spec raise-run-error)
  ; Send user defined partial bindings to breaks
  (map instance (hash-values (Bound-pbindings (Run-spec-bounds run-spec))))
  
  ; Get KodKod names, min sets, and max sets of Sigs and Relations
  (define-values (sig-to-bound all-atoms) ; Map<Symbol, bound>, List<Symbol>
    (get-sig-bounds run-spec raise-run-error))

  (define relation-to-bound ; Map<Symbol, bound>
    (get-relation-bounds run-spec sig-to-bound raise-run-error))

  (values sig-to-bound relation-to-bound all-atoms))

; Produce a single AST node to blame for a given relation's bound, or #f if none available
(define (get-blame-node run-spec the-rel)
  (cond [(or (not (node/expr/relation? the-rel))
             (not (Run-spec? run-spec)))
         #f]
        [else        
         (define result (hash-ref (Bound-orig-nodes (Run-spec-bounds run-spec)) the-rel #f))
         (and result (first result))]))

; get-sig-bounds :: Run-spec -> Map<Symbol, bound>, List<Symbol>
; Given a Run-spec, assigns names to each sig, assigns minimum and maximum 
; sets of atoms for each, and find the total number of atoms needed (including ints).
(define (get-sig-bounds run-spec raise-run-error)
  ;;;;; Helpers for extracting declared relational bounds from the run-spec
  (define pbindings (Bound-pbindings (Run-spec-bounds run-spec)))  
  (define (get-bound-lower sig)
    (define pbinding (hash-ref pbindings sig #f))
    (@and pbinding ;; !!!
          (map car (set->list (sbound-lower pbinding)))))
  (define (get-bound-upper sig)
    (define pbinding (hash-ref pbindings sig #f))
    (@and pbinding
          (sbound-upper pbinding)
          (map car (set->list (sbound-upper pbinding)))))

  ;;;;; Helpers for extracting declared numeric scopes from the run-spec
  (define scopes (Run-spec-scope run-spec))
  (define (get-scope-lower sig)
    (define scope (hash-ref (Scope-sig-scopes scopes) (Sig-name sig) #f))
    (@and scope (Range-lower scope)))
  (define (get-scope-upper sig)
    (define scope (hash-ref (Scope-sig-scopes scopes) (Sig-name sig) #f))
    (@and scope (Range-upper scope)))
  (define (get-scope-lower-default sig)
    (let ([actual (get-scope-lower sig)])
      (or actual
          (Range-lower (or (Scope-default-scope scopes)
                           DEFAULT-SIG-SCOPE)))))
  (define (get-scope-upper-default sig)
    (let ([actual (get-scope-upper sig)])
      (or actual
          (Range-upper (or (Scope-default-scope scopes)
                           DEFAULT-SIG-SCOPE)))))



  ; Map<Symbol, int>; keeps track of what the "next" generated atom ID should be
  (define curr-atom-number (make-hash))

  ; Sig -> Listof<Symbol>; the atom names declared by the user in a partial instance
  (define all-user-atoms 
    (apply append (for/list ([sig (get-sigs run-spec)]
                             #:when (hash-has-key? pbindings sig))
      (define bound (hash-ref pbindings sig))
      (map car (set->list (@or (sbound-upper bound) (sbound-lower bound)))))))

  ; Generate the "next" atom ID for a given sig, based on what's been generated/declared so far
  (define (get-next-name sig)
    (define atom-number (add1 (hash-ref curr-atom-number (Sig-name sig) -1)))    
    (let loop ([atom-number atom-number])
      (hash-set! curr-atom-number (Sig-name sig) atom-number)
      (define new-name (string->symbol (format "~a~a" (Sig-name sig) atom-number)))
      (if (member new-name all-user-atoms)
          (loop (add1 atom-number))
          new-name)))

  ; Generate <num> new names for sig <sig>
  (define (generate-names sig num)
    (map (thunk* (get-next-name sig)) (range num)))

  ; Overall bounds data structures, will be modified as this procedure executes
  (define lower-bounds (make-hash))
  (define upper-bounds (make-hash))

  ; Helper to populate a sig's lower bound based on relational bound given
  ;   If any #:one children lack tuple-based lower bounds, there is a risk of inconsistency
  ;   since those children must receive a fresh atom name to denote (and for #:one sigs, LB=UB)
  (define (fill-lower-by-bound sig)
    (define children-lowers
      (apply append (map fill-lower-by-bound (get-children run-spec sig))))
    (define curr-lower (get-bound-lower sig))

    ; Check that Forge isn't be asked to choose atoms ambiguously
    (when (and (not curr-lower) (Sig-one sig))
      ;; TODO: issue here is we would rather report the ancestor too, and ideally the stxloc for the bind
      (raise-run-error (format "Example or inst named members for an ancestor of 'one' sig ~a but no member name was given for ~a. This can result in inconsistency; please give bounds for ~a." (Sig-name sig) (Sig-name sig) (Sig-name sig))
                       (get-blame-node run-spec sig)))
    (define true-lower
      (remove-duplicates
        (append children-lowers
                (@or curr-lower (list)))))    
    (hash-set! lower-bounds sig true-lower)
    true-lower)

  ; Helper to populate a lower bound based on a numeric scope given
  (define (fill-lower-by-scope sig)
    (define children-lowers
      (apply append (map fill-lower-by-scope (get-children run-spec sig))))
    ;(printf "fill-lower-by-scope case for ~a; chlds-lowers: ~a ~n" sig children-lowers)
    (define curr-lower-bound (get-bound-lower sig))
    (define curr-lower-scope (get-scope-lower-default sig))
    (define true-lower
      (remove-duplicates
        (if curr-lower-bound
            (append curr-lower-bound children-lowers)
            (append (generate-names sig (@- curr-lower-scope (length children-lowers))) children-lowers))))
    (hash-set! lower-bounds sig true-lower)
    true-lower)

  (define (fill-upper-with-bound sig [parent-upper #f])
    (define curr-upper (get-bound-upper sig))
    (if curr-upper
        (let ()
          (hash-set! upper-bounds sig curr-upper)
          (map (lambda (child) (fill-upper-with-bound child curr-upper))
               (get-children run-spec sig)))
        (fill-upper-past-bound sig parent-upper)))

  (define (fill-upper-past-bound sig parent-upper)
    (when (get-bound-upper sig)
      (raise-run-error (format "Please specify an upper bound for ancestors of ~a." (Sig-name sig))
                       (get-blame-node run-spec sig)))
    (hash-set! upper-bounds sig parent-upper)
    (map (lambda (child) (fill-upper-past-bound child parent-upper))
         (get-children run-spec sig)))

  ; For use in situations where there is no existing upper (relational) bound
  (define (fill-upper-no-bound sig shared)

    ; If the sig has a relational upper bound, don't try to resolve the possible
    ; atom names etc.; ask the user to give an explicit bound on the parent, too.
    (when (get-bound-upper sig)
      (raise-run-error (format "Please specify an upper bound for ancestors of ~a." (Sig-name sig))
                       (get-blame-node run-spec sig)))
    (define curr-lower (hash-ref lower-bounds sig))

    ; Before doing anything else, confirm that if *no* scope was given for this sig,
    ; that the declared scopes for its children, combined, are not bigger than the default. 
    ; We allow a lower-bound to increase the default, but
    ; not a declared scope. This is consistent with Alloy, where many `one sig`s 
    ; can increase the default.
    (when (not (get-scope-upper sig))
      (define upper-budget
        (@max (length curr-lower)
              (get-scope-upper-default sig)))
      (define child-upper-declared-total
        (foldl (lambda (curr acc)
                 (@+ acc (or (get-scope-upper curr) 0)))
               0
               (get-children run-spec sig)))
      (when (< upper-budget child-upper-declared-total)
        (raise-run-error
         (format "Scope for ~a was not declared, so ~a would be used. \
However, the total of declared and inferred child-sig scopes was ~a. \
Please declare a sufficient scope for ~a."
                 (Sig-name sig) upper-budget child-upper-declared-total (Sig-name sig))
         (get-blame-node run-spec sig))))
    
    ; If the upper-bound's scope is bigger than the lower bound's current contents
    ;   (which should include child sigs' lower bounds), make room using atoms from parent.
    ; Otherwise, upper = lower, since there is no excess capacity.
    (if (@> (get-scope-upper-default sig) (length curr-lower))
        (hash-set! upper-bounds sig (append curr-lower shared))
        (hash-set! upper-bounds sig curr-lower))
    ; Recur on children
    (map (lambda (child) (fill-upper-no-bound child (append curr-lower shared)))
         (get-children run-spec sig)))

  ; List of all atoms that come from sigs, except Int. Will change as this procedure runs.
  (define sig-atoms (list))

  ; Start with each top-level sig
  (for ([root (get-top-level-sigs run-spec)]
        #:unless (equal? (Sig-name root) 'Int))
    (if (get-bound-upper root) ; Do we already have a tuple-based upper bound?
        (let ()           
          (fill-lower-by-bound root)
          (fill-upper-with-bound root))           
        (let ()
          (fill-lower-by-scope root) ; No tuple-based bound yet; extrapolate from scope
          (define lower-size (length (hash-ref lower-bounds root)))

          ; The budget for upper-bound atoms is either a declared size (if any) or
          ; the maximum of the lower-bound size and the default numeric bound (4). 
          (define upper-size
            (or (get-scope-upper root)
                (@max lower-size
                      (get-scope-upper-default root))))
          ;(printf "no-rel-bound case for ~a. scope=~a; default-scope:~a~n"
          ;        root (get-scope-upper root) (get-scope-upper-default root))

          ; Generate new names
          (define shared (generate-names root (@- upper-size lower-size)))
          ; This function is also responsible for validating totals (we didn't go over budget)
          (fill-upper-no-bound root shared)))
    ;(printf "filling bounds at ~a; upper = ~a; lower = ~a~n" root upper-bounds lower-bounds)
    (set! sig-atoms (append sig-atoms (hash-ref upper-bounds root))))

  ; Set the bounds for the Int built-in sig
  (define int-atoms
    (let* ([bitwidth (get-bitwidth run-spec)]
           [max-int (expt 2 (sub1 bitwidth))])
      (range (@- max-int) max-int)))
  (hash-set! lower-bounds (get-sig run-spec Int) int-atoms)
  (hash-set! upper-bounds (get-sig run-spec Int) int-atoms)

  ; Special case: allow sigs to extend Int
  (for ([sig (get-children run-spec Int)])
    (hash-set! lower-bounds (Sig-name sig) '())
    (hash-set! upper-bounds (Sig-name sig) int-atoms))  

  (define all-atoms (append int-atoms sig-atoms))

  ; for ease of understanding, just sort by first atom
  (define (tuple<? t1 t2)
    (cond [(and (symbol? t1) (symbol? t2))
           (symbol<? (first t1) (first t2))]
          [(and (number? t1) (number? t2))
           (< (first t1) (first t2))]
          [else (symbol? t1)]))

  ; Map<Symbol, bound>
  (define bounds-hash
    (for/hash ([sig (get-sigs run-spec)])
      (let* ([name (Sig-name sig)]
             [rel sig]
             [lower (map list (hash-ref lower-bounds sig))]
             ; Override generated upper bounds for #:one sigs
             [upper
              (cond [(Sig-one sig) lower]
                    [else (map list (hash-ref upper-bounds sig))])])
        ;(printf "bounds-hash at ~a; lower = ~a; upper = ~a; non-one upper = ~a~n" rel lower upper (hash-ref upper-bounds sig))                            
        (unless (subset? (list->set lower) (list->set upper))
          (raise-run-error (format "Bounds inconsistency detected for sig ~a: lower bound was ~a, which is not a subset of upper bound ~a." (Sig-name sig) lower upper)
                           (get-blame-node run-spec sig)))
        (values name (bound rel
                            (sort (remove-duplicates lower) tuple<?)
                            (sort (remove-duplicates upper) tuple<?))))))

;; Issue: one sig will overwrite with lower bound, but looking like that's empty if there's 
;;   an inst block that doesnt define it. Need to make that connection between default and provided.
;;   TODO  

  (values bounds-hash all-atoms))

; get-relation-info :: Run-spec -> Map<Symbol, bound>
; Given a Run-spec, the atoms assigned to each sig, the atoms assigned to each name,
; and the starting relation name, assigns names to each relation
; and minimum and maximum sets of atoms for each relation.
(define (get-relation-bounds run-spec sig-to-bound raise-run-error)
  (define pbindings (Bound-pbindings (Run-spec-bounds run-spec)))
  (define piecewise (Bound-piecewise (Run-spec-bounds run-spec)))
 
  (define (get-bound-lower rel)
    (define pbinding (hash-ref pbindings rel #f))
    (@and pbinding
          (sbound-lower pbinding)))
  (define (get-bound-upper rel)
    (define pbinding (hash-ref pbindings rel #f))
    (@and pbinding
          (sbound-upper pbinding)
          (sbound-upper pbinding)))
  (define (get-bound-piecewise rel)
    (hash-ref piecewise rel #f))

  (define without-succ
    (for/hash ([relation (get-relations run-spec)]
               #:unless (equal? (Relation-name relation) 'succ))
      (define sigs (get-sigs run-spec relation))
      (define sig-atoms (map (compose (curry map car )
                                      bound-upper
                                      (curry hash-ref sig-to-bound )
                                      Sig-name) 
                             sigs))
       ;(printf "~a: sig-atoms : ~a~n" relation sig-atoms)
       ;(printf "~a: raw upper : ~a~n" relation (get-bound-upper relation))
       ;(printf "~a: raw lower : ~a~n" relation (get-bound-lower relation))
      
      (define upper                   
        (let ([bound-upper (get-bound-upper relation)]
              [bound-piecewise (get-bound-piecewise relation)])
          (cond
            [(and bound-piecewise bound-upper)
             ; Error condition -- should never have both complete and piecewise on the same relation
             (raise-run-error (format "~a upper-bound had both complete and piecewise components, could not resolve them."
                                   relation)
                              (get-blame-node run-spec relation))]
            [bound-piecewise
             ;(printf "upper; bound-piecewise tuples: ~a~n" (PiecewiseBound-tuples bound-piecewise))
             ; for each admissible atom (taken from first component of the relation's declaration):
             ;   Where a piecewise entry exists: intersect with cartesian product of restricted universe.
             ;   otherwise: include the full cartesian-product for the restriction outside of that domain
             (define pw-domain (PiecewiseBound-atoms bound-piecewise))
             ;(printf "upper; sig-atoms[domain]: ~a~n" (first sig-atoms))
             ;(printf "upper; pw-domain: ~a~n" pw-domain) ; ISSUE: this is pre-eval :/ store post-eval?
             
             ; If the piecewise domain is not contained by the sig atoms, something has gone wrong;
             ; perhaps the sig was defined by numeric scope?
             (unless (subset? (list->set pw-domain) (list->set (first sig-atoms)))
               (define undeclared (set->list (set-subtract (list->set pw-domain) (list->set (first sig-atoms)))))
               (raise-run-error (format "Field ~a was bounded for atom(s): ~a, but the corresponding sig ~a contained only ~a. This might be caused by an inst or example not providing a value or bound for the sig; recall the default scope of ~a through ~a atoms will apply if no scope or bound is given."
                                        (Relation-name relation) undeclared (first sigs) (first sig-atoms) (Range-lower DEFAULT-SIG-SCOPE) (Range-upper DEFAULT-SIG-SCOPE))
                         (get-blame-node run-spec relation)))

             ; TODO: that only helps with the domain, not the range
             
             (define in-domain (set-intersect (list->set (PiecewiseBound-tuples bound-piecewise))
                                              (list->set (apply cartesian-product sig-atoms))))
             ;(printf "upper; sig-atoms product was: ~a~n" (apply cartesian-product sig-atoms))
             ;(printf "upper; in-domain: ~a~n" in-domain)
             (define out-of-domain (list->set
                                    (filter (lambda (tup)
                                              (not (member (first tup) pw-domain)))
                                            (apply cartesian-product sig-atoms))))
             ;(printf "upper; out-of-domain: ~a~n" out-of-domain)
             (set->list (set-union in-domain out-of-domain))]
            [bound-upper
             ; complete upper bound exists; intersect with the cartesian product of universe
             ; restricted to the sig-sequence in relation's declaration
             (set->list (set-intersect bound-upper
                                       (list->set (apply cartesian-product sig-atoms))))]
            [else
             ; no upper-bound given, default to cartesian product of universe, restricted
             ; to the sig-sequence in relation's declaration
             (apply cartesian-product sig-atoms)])))
      
      ;(define upper (set->list (set-intersect (get-bound-upper relation) (list->set (apply cartesian-product sig-atoms)))))
      ;(printf "~a: refined upper : ~a~n" relation upper)

      ; Piecewise lower bounds were handled in sigs-functional, before send-to-kodkod is called.
      (define lower                   
        (let ([bound-lower (get-bound-lower relation)])
            (if bound-lower
                (set->list (set-union bound-lower (list->set empty)))
                (list->set empty))))      
      ;(define lower (set->list (set-union (get-bound-lower relation) (list->set empty))))

      (unless (subset? (list->set lower) (list->set upper))
        (raise-run-error (format "Bounds inconsistency detected for field ~a: lower bound was ~a, which is not a subset of upper bound ~a." (Relation-name relation) lower upper)
                         (get-blame-node run-spec relation)))
      
      (values (Relation-name relation) 
              (bound relation lower upper))))
  
  (define ints (map car (bound-upper (hash-ref sig-to-bound 'Int))))
  (define succ-tuples (map list (reverse (rest (reverse ints))) (rest ints)))
  (hash-set without-succ 'succ (bound succ succ-tuples succ-tuples)))

; get-sig-size-preds :: Run-spec -> List<node/formula>
; Creates assertions for each Sig to restrict
; it to the correct lower/upper bound.
(define (get-sig-size-preds run-spec sig-to-bound #:error raise-run-error) 
  (define max-int (expt 2 (sub1 (get-bitwidth run-spec))))
  (apply append
    (for/list ([sig (get-sigs run-spec)]
               #:unless (equal? (Sig-name sig) 'Int))
      (match-define (bound rel bound-lower bound-upper) (hash-ref sig-to-bound (Sig-name sig)))
      (define-values (bound-lower-size bound-upper-size) (values (length bound-lower) (length bound-upper)))
      (match-define (Range int-lower int-upper) 
        (hash-ref (Scope-sig-scopes (Run-spec-scope run-spec)) (Sig-name sig) (Range #f #f)))

      ; Sub-optimal, because it points to the sig definition
      (define info (nodeinfo (nodeinfo-loc (node-info sig)) 'checklangNoCheck))

      (append
        (if (@and int-lower (@> int-lower bound-lower-size))
            (let ()
              (unless (@< int-lower max-int)
                (raise-run-error (format (string-append "Lower bound too large for given BitWidth; "
                                                        "Sig: ~a, Lower-bound: ~a, Max-int: ~a")
                                         sig int-lower (sub1 max-int))
                                 (get-blame-node run-spec sig)))
              (list (||/info info
                             (int</info info (int int-lower) (card sig))
                             (int=/info info (int int-lower) (card sig)))))
            (list))
        (if (@and int-upper (@< int-upper bound-upper-size))
            (let ()
              (unless (@< int-upper max-int)
                (raise-run-error (format (string-append "Upper bound too large for given BitWidth; "
                                                        "Sig: ~a, Upper-bound: ~a, Max-int: ~a")
                                         sig int-upper (sub1 max-int))
                                 (get-blame-node run-spec sig)))
              (list (||/info info
                             (int</info info (card sig) (int int-upper))
                             (int=/info info (card sig) (int int-upper)))))
            (list))))))


; TN TODO
; For many implicit constraints, it's either difficult or impossible to
; produce a *single* location to blame the formula on. For instance,
; the constraint that forces two sigs to be disjoint from one another
; can't be blamed solely on one of the two sigs.
; Instead, keep track of lists of sites for each implicit formula.

; get-extender-preds :: Run-spec -> List<node/formula>
; Creates assertions for each Sig which has extending Sigs so that:
; - if it is abstract, then it must equal the sum of its extenders
; -                    else it must contain the sum of its extenders
; - all extenders are pair-wise disjoint.
(define (get-extender-preds run-spec)
  (define sig-constraints (for/list ([sig (get-sigs run-spec)])
    ; get children information
    (define children-rels (get-children run-spec sig))

    ; abstract and sig1, ... extend => (= sig (+ sig1 ...))
    ; not abstract and sig is parent of sig1 => (in sig1 sig)
    ; TODO: optimize by identifying abstract sigs as sum of children
    (define (abstract sig extenders)
      ; TODO : location not correct
      (let ([loc (nodeinfo-loc (node-info sig))])
        (if (@= (length extenders) 1)
            (=/info (nodeinfo loc 'checklangNoCheck) sig (car extenders))
            (=/info (nodeinfo loc 'checklangNoCheck) sig (+ extenders)))))
    (define (parent sig1 sig2)
      ; loc of sig2?
      (let ([loc (nodeinfo-loc (node-info sig2))])
        (in/info (nodeinfo loc 'checklangNoCheck) sig2 sig1)))

    (define extends-constraints 
      (if (and (Sig-abstract sig) (cons? (get-children run-spec sig)))
          (list (abstract sig children-rels))
          (map (curry parent sig) children-rels)))

    ; sig1 and sig2 extend sig => (no (& sig1 sig2))
    ; (unless both are #:one, in which case exact-bounds should enforce this constraint)
    (define (disjoin-pair sig1 sig2)
      (let* ([loc (nodeinfo-loc (node-info sig2))]
             [info (nodeinfo loc 'checklangNoCheck)])
        (cond [(and (Sig-one sig1) (Sig-one sig2)) true]
              [else (no/info info (&/info info sig1 sig2))])))
    (define (disjoin-list a-sig a-list)
      (map (curry disjoin-pair a-sig) a-list))
    (define (disjoin a-list)
      (if (empty? a-list)
          empty
          (append (disjoin-list (first a-list) (rest a-list))
                  (disjoin (rest a-list)))))
    (define disjoint-constraints (disjoin children-rels))

    (append extends-constraints disjoint-constraints)))

  ; combine all constraints together
  (apply append sig-constraints))

; get-relation-preds :: Run-spec -> List<node/formula>
; Creates assertions for each Relation to ensure that it does not
; contain any atoms which don't populate their Sig.
(define (get-relation-preds run-spec)
  (for/list ([relation (get-relations run-spec)])
    (define sig-rels (get-sigs run-spec relation))
    (define info (nodeinfo (nodeinfo-loc (node-info relation)) 'checklangNoCheck))
    (in/info info relation (->/info info sig-rels))))

#|

Algorithm (draft) for bound generation:

lowerBound1(sig)
    (explicit lower bound or {}) union
    union of lowerBound(sig.children)

lowerBound2(sig)
    if sig has lower tuple bound
        lower tuple bound union union of lowerBound(sig.children)
    else
        union of lowerBound(sig.children) + generate names to make lower scope of sig


fillUpper1(current, [parentUpper #f]):
    if partialBounds.upper has current
        current.upper = partialBounds.upper(current)
        map fillUpper1(_, current.upper) onto current.children
    else
        fillUpper2(current, parentUpper)

fillUpper2(current, parentUpper):
    assert partialBounds.upper not has current
    current.upper = parentUpper
    map fillUpper2(_, current.upper) onto current.children

fillUpper3(current, shared):
    assert partialBounds.upper not has current
    current.upper = current.lower + shared
    map fillUpper3(_, shared) onto current.children

for root in root sigs
    if root has tuple upper bound
        fillUpper1(root)

    else (root does not have tuple upper bound)
        upperSize = 
            root's numerical upper bound, if present
            maximum of #root.lower and default upper

        shared = generate(upperSize - #root.lower)
        fillUpper3(root, shared)

|#
